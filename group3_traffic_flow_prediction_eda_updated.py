# -*- coding: utf-8 -*-
"""Group3_Traffic_Flow_Prediction_EDA_updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mB_XAIik-1lvPOhbUs_i7LwbtQjtuQFE
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

# Load data
df = pd.read_csv("traffic_weather_full2020.csv")
df.head()

df.info()

"""### Data Processing"""

wind_speed = df['Wind Speed'].unique()
wind_speed

wind_gust = df['Wind Gust'].unique()
wind_gust

# Define the function for extracting float numbers
def extract_float(value, string):
    return float(str(value).strip().replace(string, ''))

# Extract number from 'Wind Speed' and 'Wind Gust' columns and then convert to float
df['Wind Speed'] = df['Wind Speed'].apply(lambda x: extract_float(x, 'mph'))
df['Wind Gust'] = df['Wind Gust'].apply(lambda x: extract_float(x, 'mph'))

# Extract number from 'Dew Point' and 'Temperature' and then convert to float
df['Temperature'] = df['Temperature'].apply(lambda x: extract_float(x, 'F'))
df['Dew Point'] = df['Dew Point'].apply(lambda x: extract_float(x, 'F'))

df.head()

# Check if '5 Minutes' and 'Hour' columns are identical
are_columns_identical = (df['5 Minutes'] == df['Hour']).all()

print(f"Are the '5 Minutes' and 'Hour' columns identical? {are_columns_identical}")

# Convert the '5 Minutes' column to datetime
df['5 Minutes'] = pd.to_datetime(df['5 Minutes'], errors='coerce')

# Keep only the hour in the 'Hour' colum
df['Hour'] = df['5 Minutes'].dt.hour

df['Day_of_Month'] = df['5 Minutes'].dt.day

# Drop unrelavant column 'Time'
df = df.drop(columns=['Time', 'Day'])

"""### Handling Missing Values"""

# Remove duplicates
df.drop_duplicates(inplace=True)

print(f"Missing values percentage (%):")
df.isnull().sum()/len(df) * 100

# Fill NA values with the last known value (forward fill)
df['Wind'] = df['Wind'].ffill()
df['Condition'] = df['Condition'].ffill()

print(f"Missing values percentage (%) after imputation:")
df.isnull().sum() / len(df) * 100

df.info()

"""### Feature Engineering

#### Creating lag features
"""

# Create lag features (for previous 1, 2, and 3 intervals)
df['Flow_Lag1'] = df['Flow'].shift(1)
df['Flow_Lag2'] = df['Flow'].shift(2)
df['Flow_Lag3'] = df['Flow'].shift(3)

# Drop rows with NaN values in the lag features
df = df.dropna(subset=['Flow_Lag1', 'Flow_Lag2', 'Flow_Lag3'])

df.isnull().sum()

"""### Exploratory Data Analysis (EDA)

####  Univariate Analysis
"""

df.describe()

"""Numerical Variables:

Temperature, Dew Point, Humidity, Wind Speed, Wind Gust, Pressure, Precip., and Flow
"""

numerical_cols = ['Flow', '(mph)', 'Temperature', 'Dew Point', 'Humidity', 'Wind Speed', 'Wind Gust', 'Pressure',
       'Precip.']
categorical_cols = [ 'week_day', 'holidays', 'Hour',  'Condition', 'Wind']

# Set style for seaborn
sns.set(style="whitegrid")

# Plot histograms for numerical features
for i, feature in enumerate(numerical_cols, 1):
    plt.figure(figsize=(6, 4))
    sns.histplot(df[feature], bins=30, kde=True)
    plt.title(f'Distribution of {feature}')
    plt.show()

"""1. Holidays
The holiday variable is binary (0 = non-holiday, 1 = holiday). The distribution shows significantly more non-holiday days compared to holiday days.
Insight: Holidays could represent special traffic patterns (e.g., less congestion during holidays). This imbalance may impact model performance, so consider this when splitting data or building models.
2. (mph) – Speed Limit/Driving Speed
The distribution is heavily skewed towards higher speeds, with most observations concentrated between 60–70 mph.
Insight: The skew suggests that the dataset might be capturing data from highways or roads with high-speed limits. This could imply different traffic dynamics compared to urban settings.
3. Pressure
The pressure distribution is nearly normal, with most values centered around 29.1–29.2 inHg.
Insight: Since atmospheric pressure is relatively stable, its impact on traffic might be subtle. However, small fluctuations may indicate changing weather conditions (e.g., storms, which could reduce traffic flow).
4. Temperature
The temperature distribution peaks around 60°F and is slightly right-skewed, with fewer occurrences of temperatures above 80°F or below 40°F.
Insight: This distribution shows moderate weather conditions, which could be ideal for driving. Extreme temperatures (hot or cold) are rare but could have significant effects on traffic flow when they occur.
5. Wind Gust
The distribution is extremely right-skewed, with most values concentrated at 0, indicating minimal gusty winds. Very few instances of higher gust speeds (10–60 mph) are present.
Insight: Wind gusts are rare in the dataset. Their effect, when present, could be drastic on traffic safety, but such events occur infrequently.
6. Wind Speed
The distribution is also right-skewed, with most values between 0–10 mph. Wind speeds above 15 mph are very rare.
Insight: Since most wind speeds are relatively low, moderate wind may not affect traffic much. However, spikes in wind speed could indicate adverse weather conditions that might significantly affect traffic flow.

Flow Distribution:

The distribution of traffic flow is multimodal, with peaks around 150 and 600, suggesting distinct traffic patterns. This could be influenced by different times of the day (e.g., peak hours) or days of the week (weekdays vs weekends).
There is a rapid drop after 700, implying fewer occurrences of high traffic flow, possibly representing rare, high-traffic conditions.

Insight: This distribution indicates variability in traffic conditions, which may require segmenting data into different periods (like rush hours) for better prediction accuracy.

Dew Point Distribution:

The dew point has a right-skewed distribution with most values between 40 and 55°F, peaking around 50°F.
Few data points fall below 20°F or above 60°F, indicating that extreme dew point conditions are rare.

Insight: The concentration of values around 50°F suggests relatively stable humidity levels, which may help in weather-related traffic prediction.

Humidity Distribution:

Humidity is approximately normally distributed, with a peak around 60-70%. Most values fall between 40% and 80%, indicating moderate humidity conditions.
There are fewer instances of extreme low (< 20%) or high (> 80%) humidity.
Insight: The balanced distribution of humidity indicates its steady presence, potentially impacting driving conditions like fog or wet roads, which could influence traffic flow.

Precipitation Distribution:

The precipitation data is heavily right-skewed, with most values being near zero. This indicates that there is little to no rainfall for most data points, and very few occurrences of measurable precipitation.

Insight: Since most days have no significant precipitation, the rare cases with rainfall could have a strong impact on traffic conditions when they do occur, making it a valuable variable for rare-event modeling.
"""

# Set the plot size and style
plt.figure(figsize=(12, 8))
sns.set(style="whitegrid")

# Create a count plot for each categorical column
for col in categorical_cols:
    plt.figure(figsize=(10, 6))
    sns.countplot(y=col, data=df, palette='Set2')  # Horizontal count plot
    plt.title(f'Count Plot for {col}')
    plt.xlabel('Count')
    plt.ylabel(col)
    plt.show()

"""#### Bivariate Analysis

1. Numerical vs. Numerical
"""

# Scatter Plot: Flow vs. Temperature
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Temperature', y='Flow', data=df)
plt.title('Scatter Plot: Flow vs. Temperature')
plt.show()

# Scatter Plot: Flow vs. Wind Speed
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Wind Speed', y='Flow', data=df)
plt.title('Scatter Plot: Flow vs. Wind Speed')
plt.show()

# Scatter Plot: Flow vs. Humidity
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Humidity', y='Flow', data=df)
plt.title('Scatter Plot: Flow vs. Humidity')
plt.show()

"""2. Categorical vs. Numerical"""

# Plot the box plot without modifying the dataset
plt.figure(figsize=(8, 6))
sns.boxplot(x='holidays', y='Flow', data=df)
plt.title('Box Plot: Flow by Holiday')
plt.xlabel('Holiday')  # Optional: Renaming the x-axis label for clarity
plt.xticks([0, 1], ['No', 'Yes'])  # Change x-axis labels to 'No' and 'Yes'
plt.show()

# Box Plot: Flow by Month of Day
plt.figure(figsize=(8, 6))
sns.boxplot(x='Day_of_Month', y='Flow', data=df)
plt.title('Box Plot: Flow by Month of Day')
plt.show()

# Box Plot: Flow by Week day
plt.figure(figsize=(8, 6))
sns.boxplot(x='week_day', y='Flow', data=df)
plt.title('Box Plot: Flow by Week day')
plt.show()

# Box Plot: Flow by Hour
plt.figure(figsize=(8, 6))
sns.boxplot(x='Hour', y='Flow', data=df)
plt.title('Box Plot: Flow by Hour')
plt.show()

# Bar Plot: Average Flow by Condition
plt.figure(figsize=(8, 6))
sns.barplot(x='Condition', y='Flow', data=df, estimator=np.mean)
plt.title('Bar Plot: Average Flow by Weather Condition')
plt.xticks(rotation=45)
plt.show()

# Violin Plot: Wind Speed by Hour
plt.figure(figsize=(8, 6))
sns.violinplot(x='Hour', y='Wind Speed', data=df)
plt.title('Violin Plot: Wind Speed by Hour')
plt.show()

"""#### Multivariate Analysis

1. Correlation Heatmap (Numerical Variables)
"""

plt.figure(figsize=(10, 8))
corr_matrix = df[['Flow', 'Temperature', 'Humidity', 'Wind Speed', 'Wind Gust',
       'Precip.', 'Pressure', 'Dew Point', 'Flow_Lag1','Flow_Lag2','Flow_Lag3']].corr()
sns.heatmap(corr_matrix, annot=True, center=0, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Heatmap of Numerical Variables')
plt.show()

"""lag features (representing previous traffic flow values) show a strong correlation with current flow, highlighting the time-dependent nature of traffic and the importance of incorporating past flow data."""

corr_matrix



df = pd.read_csv("traffic_weather_full2020.csv")
df.head()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Convert 'Day' column to datetime if it isn't already
df['Day'] = pd.to_datetime(df['Day'])

# Plot traffic flow over time
plt.figure(figsize=(12, 6))
plt.plot(df['Day'], df['Flow'], color='blue')
plt.title('Traffic Flow Over Time')
plt.xlabel('Date')
plt.ylabel('Traffic Flow')
plt.show()

# Map week_day to meaningful names if needed
day_mapping = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday',
               5: 'Friday', 6: 'Saturday', 7: 'Sunday'}
df['DayOfWeek'] = df['week_day'].map(day_mapping)

# Calculate average flow per day of the week
avg_flow_by_day = df.groupby('DayOfWeek')['Flow'].mean().reindex(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'])

plt.figure(figsize=(10, 5))
sns.barplot(x=avg_flow_by_day.index, y=avg_flow_by_day.values, palette="viridis")
plt.title('Average Traffic Flow by Day of the Week')
plt.xlabel('Day of the Week')
plt.ylabel('Average Traffic Flow')
plt.show()



# Function to convert temperature and other weather-related columns to numerical values
def convert_temperature(temp_str):
    """Converts temperature strings like '55 F' to float (e.g., 55.0)."""
    try:
        # Remove any non-numeric characters and convert to float
        return float(temp_str.replace("F", "").strip())
    except:
        return None

# Apply the conversion to relevant columns
df['Temperature'] = df['Temperature'].apply(convert_temperature)
df['Dew Point'] = df['Dew Point'].apply(convert_temperature)

# check non-numeric entries
columns_to_check = ['Wind Speed', 'Wind Gust']

# Find non-numeric entries in each specified column
for column in columns_to_check:
    non_numeric = df[pd.to_numeric(df[column], errors='coerce').isnull()]

# Replace 'mph' only in values containing 'mph' and keep numeric values as is
df['Wind Speed'] = df['Wind Speed'].apply(lambda x: pd.to_numeric(str(x).replace('mph', '').strip()) if 'mph' in str(x) else pd.to_numeric(x, errors='coerce'))
df['Wind Gust'] = df['Wind Gust'].apply(lambda x: pd.to_numeric(str(x).replace('mph', '').strip()) if 'mph' in str(x) else pd.to_numeric(x, errors='coerce'))

# check for non-numeric
columns_to_check = ['Wind Speed', 'Wind Gust', 'Temperature', 'Dew Point']

for column in columns_to_check:
    non_numeric = df[pd.to_numeric(df[column], errors='coerce').isnull()]



# Convert time and date fields to datetime
df['Hour'] = pd.to_datetime(df['Hour'], errors='coerce')
df['Day'] = pd.to_datetime(df['Day'], errors='coerce')
df['IsWeekend'] = df['week_day'].apply(lambda x: 1 if x >=6 else 0)
df.head()

print(df.columns)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

if 'Hour' in df.columns:
    if pd.api.types.is_datetime64_any_dtype(df['Hour']):
        df['hour'] = df['Hour'].dt.hour
    else:
        df['hour'] = pd.to_numeric(df['Hour'], errors='coerce').astype('Int64', errors='ignore')
else:
    df['hour'] = pd.to_datetime(df['datetime']).dt.hour

df['Flow'] = pd.to_numeric(df['Flow'], errors='coerce')

hourly_flow = df.groupby('hour', as_index=True)['Flow'].mean()
hourly_flow = hourly_flow.reindex(range(0, 24), fill_value=0)

plt.figure(figsize=(10, 6))
sns.lineplot(x=hourly_flow.index, y=hourly_flow.values, marker='o')
plt.title('Average Traffic Flow by Hour of the Day')
plt.xlabel('Hour of the Day')
plt.ylabel('Average Traffic Flow (vehicles/hour)')
plt.grid(True)
plt.xticks(range(0, 24))
plt.tight_layout()
plt.show()

# Calculate average flow by weather condition
avg_flow_by_condition = df.groupby('Condition')['Flow'].mean().sort_values()

plt.figure(figsize=(12, 6))
sns.barplot(x=avg_flow_by_condition.index, y=avg_flow_by_condition.values, palette="coolwarm")
plt.title('Average Traffic Flow by Weather Condition')
plt.xlabel('Weather Condition')
plt.ylabel('Average Traffic Flow')
plt.xticks(rotation=45)  # Rotate for readability
plt.show()

# Map holiday values to meaningful labels if needed
df['IsHoliday'] = df['holidays'].apply(lambda x: 'Holiday' if x == 1 else 'Non-Holiday')

# Calculate average flow for holidays and non-holidays
avg_flow_holiday = df.groupby('IsHoliday')['Flow'].mean()

plt.figure(figsize=(8, 5))
sns.barplot(x=avg_flow_holiday.index, y=avg_flow_holiday.values, palette="Blues")
plt.title('Average Traffic Flow on Holidays vs. Non-Holidays')
plt.xlabel('Holiday Status')
plt.ylabel('Average Traffic Flow')
plt.show()

